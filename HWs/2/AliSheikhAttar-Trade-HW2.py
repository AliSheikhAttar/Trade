# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LbL11N4zxBAzxIlQQaf1_4OvxsxoZ3D0
"""

import pandas as pd
import numpy as np

"""# Section 1"""

def calculate_macd(close_prices):
    short_period=12
    long_period=26
    signal_period=9

    short_ema = close_prices.ewm(span=short_period, adjust=False).mean()
    long_ema = close_prices.ewm(span=long_period, adjust=False).mean()

    macd_line = short_ema - long_ema
    signal_line = macd_line.ewm(span=signal_period, adjust=False).mean()

    return macd_line, signal_line

def calculate_rsi(close_prices):
    period=14
    delta = close_prices.diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi

def backtest_strategy(close_prices: pd.Series, initial_capital: float):
    # indicators
    macd_line, signal_line = calculate_macd(close_prices)
    rsi = calculate_rsi(close_prices)

    in_position = False  # True means we are in a position, False means no position
    equity = pd.Series(data=[0]*len(close_prices), index=close_prices.index)
    equity.iloc[0] = initial_capital  # Starting with initial capital on all days

    for i in range(1, len(close_prices)):
        # Entry condition: MACD crosses above Signal and RSI > 48
        if (not in_position and macd_line.iloc[i] > signal_line.iloc[i]) and (macd_line.iloc[i - 1] <= signal_line.iloc[i - 1]) and (rsi.iloc[i] > 48):
            in_position = True  # Enter position

        # Exit condition: MACD crosses below Signal
        elif (in_position and macd_line.iloc[i] < signal_line.iloc[i]) and (macd_line.iloc[i - 1] >= signal_line.iloc[i - 1]):
            in_position = False  # Exit position

        # Calculate daily equity
        if in_position:
            equity.iloc[i] = equity.iloc[i - 1] * (1 + ((close_prices.iloc[i] - close_prices.iloc[i-1]) / close_prices.iloc[i-1]))  # Gain or loss if in position
        else:
            equity.iloc[i] = equity.iloc[i - 1]  # Capital remains the same if out of position

    return equity

"""# Section 2"""

def calculate_netProfit(equity):
    return equity.iloc[-1] - equity.iloc[0]

def calculate_max_drawdown(equity):
    peak = equity.cummax()
    drawdown = (equity - peak) / peak
    return drawdown.min()*100

def calculate_drawdown_duration(equity_curve):
    cumulative_max = equity_curve.cummax()
    drawdown = equity_curve / cumulative_max - 1
    in_drawdown = drawdown < 0
    drawdown_durations = in_drawdown.astype(int).groupby((in_drawdown != in_drawdown.shift()).cumsum()).cumsum()

    max_duration = drawdown_durations.max()
    return max_duration, drawdown_durations

def calculate_annual_sharp_ratio(equity, N=255, rf=0.04):
    returns = equity.pct_change()
    mean = returns.mean() * N -rf
    sigma = returns.std() * np.sqrt(N)
    return mean / sigma

def calculate_annual_sortino_ratio(equity, N=255,rf=0.04):
    returns = equity.pct_change()
    mean = returns.mean() * N -rf
    std_neg = returns[returns<0].std()*np.sqrt(N)
    return mean/std_neg

"""# Section 3"""

import yfinance as yf
import pandas as pd

tickers = {"BTC-USD", "ETH-USD", "DOGE-USD"}

start_date = "2022-10-01"
end_date = "2024-10-01"

crypto_data = {}

# Download data for each cryptocurrency
for ticker in tickers:
    data = yf.download(ticker, start=start_date, end=end_date)
    crypto_data[ticker] = data['Adj Close']
Bitcoin_adj_closes = pd.Series(crypto_data['BTC-USD'].values[:,0])
Ethereum_adj_closes = pd.Series(crypto_data['ETH-USD'].values[:,0])
Dogecoin_adj_closes = pd.Series(crypto_data['DOGE-USD'].values[:,0])

equity4Bitcoin = backtest_strategy(Bitcoin_adj_closes, 100)
equity4Ethereum = backtest_strategy(Ethereum_adj_closes, 100)
equity4Dogecoin = backtest_strategy(Dogecoin_adj_closes, 100)

def calculate_measures(equity, crypto):
  Net_proit = calculate_netProfit(equity)
  Maximum_drawdown = calculate_max_drawdown(equity)
  Maximum_drawdown_period, Duration_of_drawdown = calculate_drawdown_duration(equity)
  Annual_sharp_ratio = calculate_annual_sharp_ratio(equity)
  Annual_sortino_ratio = calculate_annual_sortino_ratio(equity)
  print(f"Net profit for {crypto} is {Net_proit}$")
  print(f"Maximum drawdown for {crypto} is {Maximum_drawdown}")
  print(f"Duration of drawdown for {crypto} is \n{Duration_of_drawdown.values}")
  print(f"Maximum drawdown period for {crypto} is {Maximum_drawdown_period} days")
  print(f"Annual sharpe ratio for {crypto} is {Annual_sharp_ratio}")
  print(f"Annual sortino ratio for {crypto} is {Annual_sortino_ratio}")

"""## Bitcoin"""

calculate_measures(equity4Bitcoin, "Bitcoin")

"""## Ethereum"""

calculate_measures(equity4Ethereum, "Ethereum")

"""## Dogecoin"""

calculate_measures(equity4Dogecoin, "Dogecoin")