# -*- coding: utf-8 -*-
"""AliSheikhAttar_99542222_Trade_HW3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nC_bcKqI1gdRQNdZo7rp_1I0JMtGgB9d

# Libraries
"""

!pip install yfinance pandas ta

import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from ta.momentum import RSIIndicator
from ta.volatility import BollingerBands, KeltnerChannel

"""# Section 1"""

cryptos = ['BTC-USD', 'ETH-USD']

start_date = '2023-02-01'
end_date = '2024-02-01'

five_day_data = yf.download(cryptos, start=start_date, end=end_date, interval='5d')

print(five_day_data.head())

five_day_data.columns = ['_'.join(col) for col in five_day_data.columns]

print(five_day_data.columns)

def calculate_bollinger_bands(df, cryptos, window=20, multiplier=2):
    for crypto in cryptos:
        close = df[f'Close_{crypto}']
        sma = close.rolling(window=window).mean()
        std = close.rolling(window=window).std()
        df[f'Upper_Band_{crypto}'] = sma + (multiplier * std)
        df[f'Lower_Band_{crypto}'] = sma - (multiplier * std)
    return df

def calculate_keltner_channels(df, cryptos, window=20, window_atr=14, multiplier=2):

    for crypto in cryptos:
        high = df[f'High_{crypto}']
        low = df[f'Low_{crypto}']
        close = df[f'Close_{crypto}']

        tr1 = high - low
        tr2 = (high - close.shift(1)).abs()
        tr3 = (low - close.shift(1)).abs()
        tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
        df[f'TR_{crypto}'] = tr

        atr = tr.rolling(window=window_atr, min_periods=window_atr).mean()
        df[f'ATR_{crypto}'] = atr

        sma = close.rolling(window=window, min_periods=window).mean()
        df[f'SMA_{crypto}'] = sma

        df[f'Keltner_Upper_{crypto}'] = sma + (multiplier * atr)

        df[f'Keltner_Lower_{crypto}'] = sma - (multiplier * atr)

    return df

def calculate_RSI_pandas(df, cryptos, window=7, ob=70, os=30):

    for crypto in cryptos:
      delta = df[f'Close_{crypto}'].diff()
      gain = delta.clip(lower=0)
      loss = -delta.clip(upper=0)

      avg_gain = gain.ewm(alpha=1/window, min_periods=window).mean()
      avg_loss = loss.ewm(alpha=1/window, min_periods=window).mean()

      rs = avg_gain / avg_loss
      rsi = 100 - (100 / (1 + rs))

      df[f'RSI_{crypto}'] = rsi

      df[f'RSI_Overbought_{crypto}'] = df[f'RSI_{crypto}'] > ob
      df[f'RSI_Oversold_{crypto}'] = df[f'RSI_{crypto}'] < os

    return df

def generate_trade_signals(df, cryptos):

    for crypto in cryptos:
        buy_condition = (
            (df[f'Close_{crypto}'] < df[f'Lower_Band_{crypto}']) &
            (df[f'Close_{crypto}'] < df[f'Keltner_Lower_{crypto}']) &
            (df[f'RSI_Oversold_{crypto}'])
        )

        sell_condition = (
            (df[f'Close_{crypto}'] > df[f'Upper_Band_{crypto}']) &
            (df[f'Close_{crypto}'] > df[f'Keltner_Upper_{crypto}']) &
            (df[f'RSI_Overbought_{crypto}'])
        )

        df[f'Buy_Signal_{crypto}'] = buy_condition
        df[f'Sell_Signal_{crypto}'] = sell_condition

    return df

def plot_trade_signals(df, crypto):

    plt.figure(figsize=(14, 7))

    plt.plot(df.index, df[f'Close_{crypto}'], label='Close Price', color='blue')

    plt.plot(df.index, df[f'Upper_Band_{crypto}'], label='Bollinger Upper Band', color='magenta', linestyle='--')
    plt.plot(df.index, df[f'Lower_Band_{crypto}'], label='Bollinger Lower Band', color='cyan', linestyle='--')

    plt.plot(df.index, df[f'Keltner_Upper_{crypto}'], label='Keltner Upper Channel', color='green', linestyle='--')
    plt.plot(df.index, df[f'Keltner_Lower_{crypto}'], label='Keltner Lower Channel', color='red', linestyle='--')

    buy_signals = df[df[f'Buy_Signal_{crypto}']]
    plt.scatter(buy_signals.index, buy_signals[f'Close_{crypto}'], marker='^', color='green', label='Buy Signal', s=100)

    sell_signals = df[df[f'Sell_Signal_{crypto}']]
    plt.scatter(sell_signals.index, sell_signals[f'Close_{crypto}'], marker='v', color='red', label='Sell Signal', s=100)

    plt.title(f'{crypto} Price with Bollinger Bands, Keltner Channels, and Trade Signals')
    plt.xlabel('Date')
    plt.ylabel('Price (USD)')
    plt.legend()
    plt.grid(True)
    plt.show()

def backtest_strategy(df, cryptos, initial_capital=1000):

    results = {}

    for crypto in cryptos:
        capital = initial_capital
        position = 0
        buy_price = 0
        shares = 0

        df[f'Portfolio_Value_{crypto}'] = initial_capital

        for idx, row in df.iterrows():
            close_price = row[f'Close_{crypto}']
            buy_signal = row[f'Buy_Signal_{crypto}']
            sell_signal = row[f'Sell_Signal_{crypto}']

            if buy_signal and position == 0:
                position = 1
                buy_price = close_price
                shares = capital / buy_price
                capital = 0
                portfolio_value = shares * close_price
                df.at[idx, f'Portfolio_Value_{crypto}'] = portfolio_value
                print(f"{idx.date()} - {crypto}: خرید به قیمت {buy_price:.2f} USD")

            elif sell_signal and position == 1:
                position = 0
                sell_price = close_price
                capital = shares * sell_price
                shares = 0
                portfolio_value = capital
                df.at[idx, f'Portfolio_Value_{crypto}'] = portfolio_value
                print(f"{idx.date()} - {crypto}: فروش به قیمت {sell_price:.2f} USD")

            else:
                if position == 1:
                    portfolio_value = shares * close_price
                else:
                    portfolio_value = capital
                df.at[idx, f'Portfolio_Value_{crypto}'] = portfolio_value

        if position == 1:
            sell_price = df[f'Close_{crypto}'].iloc[-1]
            capital = shares * sell_price
            df.at[df.index[-1], f'Portfolio_Value_{crypto}'] = capital
            print(f"{df.index[-1].date()} - {crypto}: فروش نهایی به قیمت {sell_price:.2f} USD")

        df[f'Returns_{crypto}'] = df[f'Portfolio_Value_{crypto}'].pct_change().fillna(0)

        df[f'Cumulative_Returns_{crypto}'] = (1 + df[f'Returns_{crypto}']).cumprod()

        total_return = df[f'Cumulative_Returns_{crypto}'].iloc[-1] - 1
        net_profit = capital - initial_capital
        daily_returns = df[f'Returns_{crypto}']

        sharpe_ratio = daily_returns.mean() / daily_returns.std() * np.sqrt(252)

        negative_returns = daily_returns[daily_returns < 0]
        sortino_ratio = daily_returns.mean() / negative_returns.std() * np.sqrt(252) if not negative_returns.empty else np.nan

        cumulative = df[f'Cumulative_Returns_{crypto}']
        peak = cumulative.cummax()
        drawdown = (cumulative - peak) / peak
        max_drawdown = drawdown.min()

        results[crypto] = {
            'Total Return (%)': total_return * 100,
            'Net Profit ($)': net_profit,
            'Sharpe Ratio': sharpe_ratio,
            'Sortino Ratio': sortino_ratio,
            'Max Drawdown (%)': max_drawdown * 100
        }

    return results

"""## Parametes I"""

five_day_data = calculate_bollinger_bands(five_day_data, cryptos, window=20, multiplier=2)
five_day_data = calculate_keltner_channels(five_day_data, cryptos, window=20, window_atr=14, multiplier=2)
five_day_data = calculate_RSI_pandas(five_day_data, cryptos, ob=70, os=30)
five_day_data = generate_trade_signals(five_day_data, cryptos)
signal_columns = [f'Buy_Signal_{crypto}' for crypto in cryptos] + [f'Sell_Signal_{crypto}' for crypto in cryptos]

print(five_day_data[signal_columns].tail())

initial_capital = 1000
results = backtest_strategy(five_day_data, cryptos, initial_capital=initial_capital)

for crypto, metrics in results.items():
    print(f"\nنتایج Backtest برای {crypto}:")
    for metric, value in metrics.items():
        print(f"{metric}: {value:.2f}")

for crypto in cryptos:
    plot_trade_signals(five_day_data, crypto)

"""## Parameters II"""

five_day_data = calculate_bollinger_bands(five_day_data, cryptos, window=5, multiplier=2)
five_day_data = calculate_keltner_channels(five_day_data, cryptos, window=5, window_atr=14, multiplier=2)
five_day_data = calculate_RSI_pandas(five_day_data, cryptos, window=5, ob=70, os=30)
five_day_data = generate_trade_signals(five_day_data, cryptos)
signal_columns = [f'Buy_Signal_{crypto}' for crypto in cryptos] + [f'Sell_Signal_{crypto}' for crypto in cryptos]

print(five_day_data[signal_columns].tail())

initial_capital = 1000
results = backtest_strategy(five_day_data, cryptos, initial_capital=initial_capital)

for crypto, metrics in results.items():
    print(f"\nنتایج Backtest برای {crypto}:")
    for metric, value in metrics.items():
        print(f"{metric}: {value:.2f}")

for crypto in cryptos:
    plot_trade_signals(five_day_data, crypto)

"""## Parameter III"""

five_day_data = calculate_bollinger_bands(five_day_data, cryptos, window=10, multiplier=1)
five_day_data = calculate_keltner_channels(five_day_data, cryptos, window=10, window_atr=14, multiplier=2)
five_day_data = calculate_RSI_pandas(five_day_data, cryptos, window=10, ob=70, os=30)
five_day_data = generate_trade_signals(five_day_data, cryptos)
signal_columns = [f'Buy_Signal_{crypto}' for crypto in cryptos] + [f'Sell_Signal_{crypto}' for crypto in cryptos]

print(five_day_data[signal_columns].tail())

initial_capital = 1000
results = backtest_strategy(five_day_data, cryptos, initial_capital=initial_capital)

for crypto, metrics in results.items():
    print(f"\nنتایج Backtest برای {crypto}:")
    for metric, value in metrics.items():
        print(f"{metric}: {value:.2f}")

for crypto in cryptos:
    plot_trade_signals(five_day_data, crypto)

"""## Parametes IV"""

five_day_data = calculate_bollinger_bands(five_day_data, cryptos, window=20, multiplier=1)
five_day_data = calculate_keltner_channels(five_day_data, cryptos, window=20, window_atr=14, multiplier=2)
five_day_data = calculate_RSI_pandas(five_day_data, cryptos, ob=70, os=30)
five_day_data = generate_trade_signals(five_day_data, cryptos)
signal_columns = [f'Buy_Signal_{crypto}' for crypto in cryptos] + [f'Sell_Signal_{crypto}' for crypto in cryptos]

print(five_day_data[signal_columns].tail())

initial_capital = 1000
results = backtest_strategy(five_day_data, cryptos, initial_capital=initial_capital)

for crypto, metrics in results.items():
    print(f"\nنتایج Backtest برای {crypto}:")
    for metric, value in metrics.items():
        print(f"{metric}: {value:.2f}")

for crypto in cryptos:
    plot_trade_signals(five_day_data, crypto)

"""# Parameter V"""

five_day_data = calculate_bollinger_bands(five_day_data, cryptos, window=25, multiplier=1)
five_day_data = calculate_keltner_channels(five_day_data, cryptos, window=25, window_atr=14, multiplier=1)
five_day_data = calculate_RSI_pandas(five_day_data, cryptos, ob=70, os=30)
five_day_data = generate_trade_signals(five_day_data, cryptos)
signal_columns = [f'Buy_Signal_{crypto}' for crypto in cryptos] + [f'Sell_Signal_{crypto}' for crypto in cryptos]

print(five_day_data[signal_columns].tail())

initial_capital = 1000
results = backtest_strategy(five_day_data, cryptos, initial_capital=initial_capital)

for crypto, metrics in results.items():
    print(f"\nنتایج Backtest برای {crypto}:")
    for metric, value in metrics.items():
        print(f"{metric}: {value:.2f}")

for crypto in cryptos:
    plot_trade_signals(five_day_data, crypto)

"""# Parameters VI"""

five_day_data = calculate_bollinger_bands(five_day_data, cryptos, window=25, multiplier=2.5)
five_day_data = calculate_keltner_channels(five_day_data, cryptos, window=25, window_atr=14, multiplier=2.5)
five_day_data = calculate_RSI_pandas(five_day_data, cryptos, ob=70, os=30)
five_day_data = generate_trade_signals(five_day_data, cryptos)
signal_columns = [f'Buy_Signal_{crypto}' for crypto in cryptos] + [f'Sell_Signal_{crypto}' for crypto in cryptos]

print(five_day_data[signal_columns].tail())

initial_capital = 1000
results = backtest_strategy(five_day_data, cryptos, initial_capital=initial_capital)

for crypto, metrics in results.items():
    print(f"\nنتایج Backtest برای {crypto}:")
    for metric, value in metrics.items():
        print(f"{metric}: {value:.2f}")

for crypto in cryptos:
    plot_trade_signals(five_day_data, crypto)

"""## Parameters VII"""

five_day_data = calculate_bollinger_bands(five_day_data, cryptos, window=5, multiplier=2.5)
five_day_data = calculate_keltner_channels(five_day_data, cryptos, window=5, window_atr=10, multiplier=2)
five_day_data = calculate_RSI_pandas(five_day_data, cryptos, window=5, ob=70, os=30)
five_day_data = generate_trade_signals(five_day_data, cryptos)
signal_columns = [f'Buy_Signal_{crypto}' for crypto in cryptos] + [f'Sell_Signal_{crypto}' for crypto in cryptos]

print(five_day_data[signal_columns].tail())

initial_capital = 1000
results = backtest_strategy(five_day_data, cryptos, initial_capital=initial_capital)

for crypto, metrics in results.items():
    print(f"\nنتایج Backtest برای {crypto}:")
    for metric, value in metrics.items():
        print(f"{metric}: {value:.2f}")

for crypto in cryptos:
    plot_trade_signals(five_day_data, crypto)

"""## Parametes VIII"""

five_day_data = calculate_bollinger_bands(five_day_data, cryptos, window=15, multiplier=0.5)
five_day_data = calculate_keltner_channels(five_day_data, cryptos, window=15, window_atr=15, multiplier=1.5)
five_day_data = calculate_RSI_pandas(five_day_data, cryptos, window=5, ob=70, os=30)
five_day_data = generate_trade_signals(five_day_data, cryptos)
signal_columns = [f'Buy_Signal_{crypto}' for crypto in cryptos] + [f'Sell_Signal_{crypto}' for crypto in cryptos]

print(five_day_data[signal_columns].tail())

initial_capital = 1000
results = backtest_strategy(five_day_data, cryptos, initial_capital=initial_capital)

for crypto, metrics in results.items():
    print(f"\nنتایج Backtest برای {crypto}:")
    for metric, value in metrics.items():
        print(f"{metric}: {value:.2f}")

for crypto in cryptos:
    plot_trade_signals(five_day_data, crypto)

"""## Parameters IX"""

five_day_data = calculate_bollinger_bands(five_day_data, cryptos, window=15, multiplier=0.5)
five_day_data = calculate_keltner_channels(five_day_data, cryptos, window=15, window_atr=15, multiplier=1.5)
five_day_data = calculate_RSI_pandas(five_day_data, cryptos, window=5, ob=80, os=20)
five_day_data = generate_trade_signals(five_day_data, cryptos)
signal_columns = [f'Buy_Signal_{crypto}' for crypto in cryptos] + [f'Sell_Signal_{crypto}' for crypto in cryptos]

print(five_day_data[signal_columns].tail())

initial_capital = 1000
results = backtest_strategy(five_day_data, cryptos, initial_capital=initial_capital)

for crypto, metrics in results.items():
    print(f"\nنتایج Backtest برای {crypto}:")
    for metric, value in metrics.items():
        print(f"{metric}: {value:.2f}")

for crypto in cryptos:
    plot_trade_signals(five_day_data, crypto)

"""# Section 2"""

def calculate_sharpe_ratio(returns, risk_free_rate=0.0):
    excess_returns = returns.mean() - risk_free_rate
    sharpe_ratio = excess_returns / returns.std() * np.sqrt(252)
    return sharpe_ratio

def calculate_sortino_ratio(returns, risk_free_rate=0.0):
    downside_returns = returns[returns < 0]
    if downside_returns.empty:
        return np.nan
    excess_returns = returns.mean() - risk_free_rate
    sortino_ratio = excess_returns / downside_returns.std() * np.sqrt(252)
    return sortino_ratio

def calculate_max_drawdown(cumulative_returns):
    peak = cumulative_returns.cummax()
    drawdown = (cumulative_returns - peak) / peak
    max_drawdown = drawdown.min() * 100
    return max_drawdown

def calculate_net_profit(final_capital, initial_capital=2000):
    net_profit = final_capital - initial_capital
    return net_profit

def generate_trade_signals_bollinger(df, crypto):

    df[f'Buy_Signal_{crypto}'] = (df[f'Close_{crypto}'].shift(1) <= df[f'Lower_Band_{crypto}'])

    df[f'Sell_Signal_{crypto}'] = (df[f'Close_{crypto}'].shift(1) >= df[f'Upper_Band_{crypto}'])

    return df

def backtest_bollinger_strategy(df, crypto, initial_capital=2000):

    capital = initial_capital
    position = False
    shares = 0

    df[f'Portfolio_Value_{crypto}'] = initial_capital

    for idx, row in df.iterrows():
        buy_signal = row[f'Buy_Signal_{crypto}']
        sell_signal = row[f'Sell_Signal_{crypto}']
        open_price = row[f'Open_{crypto}']

        if buy_signal and not position:
            position = True
            shares = capital / open_price
            capital = 0
            portfolio_value = shares * open_price
            df.at[idx, f'Portfolio_Value_{crypto}'] = portfolio_value
            print(f"{idx.date()} - {crypto}: خرید به قیمت {open_price:.2f} USD")

        elif sell_signal and position:
            position = False
            capital = shares * open_price
            shares = 0
            portfolio_value = capital
            df.at[idx, f'Portfolio_Value_{crypto}'] = portfolio_value
            print(f"{idx.date()} - {crypto}: فروش به قیمت {open_price:.2f} USD")

        else:
            if position:
                portfolio_value = shares * open_price
            else:
                portfolio_value = capital
            df.at[idx, f'Portfolio_Value_{crypto}'] = portfolio_value

    if position:
        sell_price = df[f'Open_{crypto}'].iloc[-1]
        capital = shares * sell_price
        df.at[df.index[-1], f'Portfolio_Value_{crypto}'] = capital
        print(f"{df.index[-1].date()} - {crypto}: فروش نهایی به قیمت {sell_price:.2f} USD")

    df[f'Returns_{crypto}'] = df[f'Portfolio_Value_{crypto}'].pct_change().fillna(0)

    df[f'Cumulative_Returns_{crypto}'] = (1 + df[f'Returns_{crypto}']).cumprod()

    total_return = df[f'Cumulative_Returns_{crypto}'].iloc[-1] - 1
    final_capital = df[f'Portfolio_Value_{crypto}'].iloc[-1]
    net_profit = calculate_net_profit(final_capital, initial_capital)
    sharpe_ratio = calculate_sharpe_ratio(df[f'Returns_{crypto}'])
    sortino_ratio = calculate_sortino_ratio(df[f'Returns_{crypto}'])
    max_drawdown = calculate_max_drawdown(df[f'Cumulative_Returns_{crypto}'])

    results = {
        'Total Return (%)': total_return * 100,
        'Net Profit ($)': net_profit,
        'Sharpe Ratio': sharpe_ratio,
        'Sortino Ratio': sortino_ratio,
        'Max Drawdown (%)': max_drawdown
    }

    return results

def download_data(cryptos, start_date, end_date, interval='1d'):

    df = yf.download(cryptos, start=start_date, end=end_date, interval=interval)

    df.columns = ['_'.join(col) if isinstance(col, tuple) else col for col in df.columns]
    return df

def plot_trade_signals(df, crypto):

    plt.figure(figsize=(14, 7))

    plt.plot(df.index, df[f'Close_{crypto}'], label='Close Price', color='blue')

    plt.plot(df.index, df[f'Upper_Band_{crypto}'], label='Bollinger Upper Band', color='magenta', linestyle='--')
    plt.plot(df.index, df[f'Lower_Band_{crypto}'], label='Bollinger Lower Band', color='cyan', linestyle='--')

    buy_signals = df[df[f'Buy_Signal_{crypto}']]
    plt.scatter(buy_signals.index, buy_signals[f'Open_{crypto}'], marker='^', color='green', label='Buy Signal', s=100)

    sell_signals = df[df[f'Sell_Signal_{crypto}']]
    plt.scatter(sell_signals.index, sell_signals[f'Open_{crypto}'], marker='v', color='red', label='Sell Signal', s=100)

    plt.title(f'{crypto} Price with Bollinger Bands and Trade Signals')
    plt.xlabel('Date')
    plt.ylabel('Price (USD)')
    plt.legend()
    plt.grid(True)
    plt.show()

def run_strategy(crypto='BTC-USD', initial_capital=2000, start_date='2023-02-01', end_date='2024-02-01', interval='1d'):

    df = download_data([crypto], start_date, end_date, interval=interval)

    df = calculate_bollinger_bands(df, [crypto], window=20, multiplier=2)

    df = generate_trade_signals_bollinger(df, crypto)

    results = backtest_bollinger_strategy(df, crypto, initial_capital=initial_capital)

    print("\nمعیارهای ارزیابی Backtest:")
    for metric, value in results.items():
        print(f"{metric}: {value:.2f}")

    plot_trade_signals(df, crypto)

run_strategy(crypto='BTC-USD', initial_capital=2000, start_date='2023-02-01', end_date='2024-02-01', interval='1d')
run_strategy(crypto='ETH-USD', initial_capital=2000, start_date='2023-02-01', end_date='2024-02-01', interval='1d')

def backtest_bollinger_strategy_with_risk_management(df, crypto, initial_capital=2000, risk_percentage=0.4):
    capital = initial_capital
    position = False
    shares = 0

    df[f'Portfolio_Value_{crypto}'] = initial_capital

    for idx, row in df.iterrows():
        buy_signal = row[f'Buy_Signal_{crypto}']
        sell_signal = row[f'Sell_Signal_{crypto}']
        open_price = row[f'Open_{crypto}']

        if buy_signal and not position:
            position = True
            investment = capital * risk_percentage
            shares = investment / open_price
            capital -= investment
            portfolio_value = shares * open_price
            df.at[idx, f'Portfolio_Value_{crypto}'] = capital + portfolio_value
            print(f"{idx.date()} - {crypto}: خرید {shares:.4f} سهم به قیمت {open_price:.2f} USD")

        elif sell_signal and position:
            position = False
            proceeds = shares * open_price
            capital += proceeds
            shares = 0
            portfolio_value = capital
            df.at[idx, f'Portfolio_Value_{crypto}'] = portfolio_value
            print(f"{idx.date()} - {crypto}: فروش به قیمت {open_price:.2f} USD و کسب {proceeds:.2f} USD")

        else:
            if position:
                portfolio_value = shares * open_price
                df.at[idx, f'Portfolio_Value_{crypto}'] = capital + portfolio_value
            else:
                df.at[idx, f'Portfolio_Value_{crypto}'] = capital

    if position:
        sell_price = df[f'Open_{crypto}'].iloc[-1]
        proceeds = shares * sell_price
        capital += proceeds
        df.at[df.index[-1], f'Portfolio_Value_{crypto}'] = capital
        print(f"{df.index[-1].date()} - {crypto}: فروش نهایی به قیمت {sell_price:.2f} USD و کسب {proceeds:.2f} USD")

    df[f'Returns_{crypto}'] = df[f'Portfolio_Value_{crypto}'].pct_change().fillna(0)

    df[f'Cumulative_Returns_{crypto}'] = (1 + df[f'Returns_{crypto}']).cumprod()

    total_return = df[f'Cumulative_Returns_{crypto}'].iloc[-1] - 1
    final_capital = df[f'Portfolio_Value_{crypto}'].iloc[-1]
    net_profit = calculate_net_profit(final_capital, initial_capital)
    sharpe_ratio = calculate_sharpe_ratio(df[f'Returns_{crypto}'])
    sortino_ratio = calculate_sortino_ratio(df[f'Returns_{crypto}'])
    max_drawdown = calculate_max_drawdown(df[f'Cumulative_Returns_{crypto}'])

    results = {
        'Total Return (%)': total_return * 100,
        'Net Profit ($)': net_profit,
        'Sharpe Ratio': sharpe_ratio,
        'Sortino Ratio': sortino_ratio,
        'Max Drawdown (%)': max_drawdown
    }

    return results

def run_strategy(crypto='BTC-USD', initial_capital=2000, start_date='2023-02-01', end_date='2024-02-01', interval='1d'):

    df = download_data([crypto], start_date, end_date, interval=interval)

    df = calculate_bollinger_bands(df, [crypto], window=20, multiplier=2)

    df = generate_trade_signals_bollinger(df, crypto)

    results = backtest_bollinger_strategy_with_risk_management(df, crypto, initial_capital=initial_capital, risk_percentage=0.4)

    print("\nمعیارهای ارزیابی Backtest:")
    for metric, value in results.items():
        print(f"{metric}: {value:.2f}")

    plot_trade_signals(df, crypto)

run_strategy(crypto='BTC-USD', initial_capital=2000, start_date='2023-02-01', end_date='2024-02-01', interval='1d')
run_strategy(crypto='ETH-USD', initial_capital=2000, start_date='2023-02-01', end_date='2024-02-01', interval='1d')